\section{Reporting}
This section will discuss the implementations for an AF macro and a Visitor macro.
It will first discuss the layout used for the macro library.
Next, hand-written implementation as written by a programmer for AF and Visitor will be presented.
These implementations will be the goalposts for the macro outputs.
Finally, the macros will be written to generate the same output.

\subsection{Library layout}
Parts of the framework being created can be used by other macros/libraries.
Thus, the macro implementations will be separated from the structures they will use.
Another reason for this choice is because the \textit{TokenStream}s, which were presented in \Fref{sec:rust-metaprogramming}, cannot be unit tested.
\textit{Syn} and \textit{quote} thus operate against a wrapper found in \textit{proc\_macro2}\footnote{https://docs.rs/proc-macro2/1.0.19/proc\_macro2/index.html} which the helper structures in this section will also use.
This leads to the libraries shown in \Fref{fig:LibraryLayout}.

\begin{figure}[h]
	\centering
	\includegraphics{Layout.1}
	\caption{Layout of libraries}
	\label{fig:LibraryLayout}
\end{figure}

Client code will use the \textit{macro-patterns} library.
\textit{Macro-patterns} will contain macro definitions as was defined in \Fref{sec:rust-metaprogramming} for Abstract Factory and Visitor.
\textit{Macro-lib} will provide syntax tree components that are missing from \textit{syn} or are simpler than \textit{syn}'s.
Finally, all the code is tested with \textit{macro-test-helpers} providing helpers dedicated to making tests easier.
The tests will not be covered in this report, but the reader should note that automated tests are used to ensure the macro outputs are identical to the hand-written implementations covered next.

\subsection{Hand-written implementations}
\label{sec:hand-written}
Typically the design pattern implementations will be written by a programmer without reusing code.
Even though this section creates macros to replace this manual process, the design patterns will be implemented here manually to know what the macro outputs should be.

\subsubsection{Simple GUI}
The design pattern implementations are built on the simple GUI library shown in \Fref{lst:client-gui} which defines:

\begin{itemize}
	\item An \textit{Element} that can create itself with a given name and return that name.
	\item A \textit{Button} that is an \textit{Element} to be clicked with text.
	\item An \textit{Input} element that can hold text inputs.
	\item A \textit{Child} enum that can be a \textit{Button} or \textit{Input}.
	\item A concrete \textit{Window} struct that can hold \textit{Child} elements.
\end{itemize}

\libraryCodeFromFile[lastline=38]{macro-client/src/gui/elements.rs}{client-gui}{Simple GUI defined by client}

The abstract \textit{Button} and \textit{Input} each have a concrete brand version -- i.e. \textit{BrandButton} and \textit{BrandInput} shown in \Fref{lst:brand-elements}.

\libraryCodeFromFile{macro-client/src/gui/brand_elements.rs}{brand-elements}{Brand GUI elements}

\subsubsection{Hand-written Abstract Factory implementation}
\Fref{lst:abstract-factory-hand} shows an implementation of AF for the GUI.
This implementation maps directly to the UML presented for AF in \Fref{sec:design-abstract-factory}.

\libraryCodeFromFile[firstline=5,lastline=17]{macro-client/src/abstract_factory_hand.rs}{abstract-factory-hand}{Hand-written abstract factory}

Line 2 imports the concrete brand elements from \Fref{lst:brand-elements}, with line 3 importing the abstract elements from \Fref{lst:client-gui}.
A factory method is defined on lines 6 to 8.
On line 10 an AF is defined using the factory method as super traits.
The \textit{Display} super trait is to show the macro can handle complex AFs.

Client code will create a concrete brand factory as follow:

\clientCodeFromFile[firstline=19,lastline=37]{macro-client/src/abstract_factory_hand.rs}

\subsubsection{Hand-written Visitor implementation}
% TODO: refer back to the UML (here and macro)
A hand-written visitor implementation can be seen in \Fref{lst:visitor-hand}.
Visitor consists of three parts:
\begin{itemize}
	\item The abstract visitor as defined on lines 3 to 14.
	\item Helper functions for traversing the object structure \cite{gamma_94_01} on lines 16 to 37.
	      This allows for default implementations on the abstract visitor to call its respective helper.
	      Doing this allows the client to write less code when their visitor will not visit each element.
	      It means client code does not need to repeat code to visit into an element's children since the client can call a helper that has the traversal code - like \textit{visit\_window} on line 27.
	\item Double dispatch reflections on lines 40 to 58.
	      With these, the client does not need to remember/match each abstract visitor method with the element they are currently using.
	      The client can just call \textit{apply} on the element and have it redirect to the correct visitor method.
\end{itemize}

\libraryCodeFromFile[firstline=5,lastline=62]{macro-client/src/visitor_hand.rs}{visitor-hand}{Hand-written visitor}

A client will write a concrete visitor as shown below.
This visitor collects the names of each element in a structure except for the names of windows to show the power of the default implementations delegating to the helpers.
Because the default implementation in \Fref{lst:visitor-hand} line 12 uses the helper on line 27, \textit{VisitorName} does not need to implement anything for \textit{Window} to be able to travers into a \textit{Window}'s children.
This visitor implements the \textit{Display} trait to be able to call \textit{to\_string()} on it.
Calling \textit{to\_string()} will join all the names this visitor collected.

\clientCodeFromFile[firstline=64,lastline=88]{macro-client/src/visitor_hand.rs}

The next client code shows how to use this visitor.
First a window, button, and input is created.
A random name is set on the input before it and the button is added to the window.
A \textit{VisitorName} is created and applied to the window.
Lastly, a test shows the visitor collected the correct names.

\clientCodeFromFile[firstline=111,lastline=128]{macro-client/src/visitor_hand.rs}

\subsection{Macros}
Rust's metaprogramming abilities will be used to create macros that can write the repeated sections in the hand-written implementations.
The outputs of each macro should be exactly the same as the manually implementations written by a programmer.
Three macros will be created in total: one to create an AF; one to implement a concrete factory for an AF; one to create a Visitor.

\subsubsection{AF macro}
The implementation of the AF macro will be used as a foundation to implement the Visitor macro.
The input passed to the macro -- defined as meta-code in \Fref{sec:metaprogramming} -- will be parsed to a model.
This model will be able to expand itself into its pattern implementation as defined in \Fref{sec:hand-written}.
A model will be composed of syntax elements.
Some of the syntax elements will come from \textit{syn} and others will have to be created.

The client meta-code for AF is as follows -- since it is the same as the hand-written implementation, it also maps directly to the AF UML given in \Fref{sec:design-abstract-factory}:
% TODO: coloring will help

\clientCodeFromFile[firstline=5,lastline=36]{macro-client/src/abstract_factory.rs}

The client needs to specify the factory method they will use.
This factory method needs to take a generic element \textit{T}.
The \textit{AbstractGuiFactory} is annotated with an attribute macro (see \Fref{sec:attribute-macro}) named \textit{abstract\_factory}.
The factory method and factory elements are passed to the macro.

The client will create their concrete \textit{BrandFactory} and use the \textit{interpolate\_traits} attribute macro to implement the factory method for each element.
Here the client uses two invocations of \textit{interpolate\_traits} since \textit{Window} is concrete and does not use the \textit{dyn} keyword.

\paragraph{Models}
Both \textit{abstract\_factory} and \textit{interpolate\_traits} take in a comma-seperated list of inputs.
The \textit{syn} library provides the \textit{Punctuated}\footnote{https://docs.rs/syn/1.0.48/syn/punctuated/struct.Punctuated.html} type to parse a list of elements seperated by any punctuation marker.
\textit{Syn} also provides \textit{Type}\footnote{https://docs.rs/syn/1.0.48/syn/enum.Type.html} for parsing Rust types that will used by the \textit{abstract\_factory} macro.
The elements passed to \textit{interpolate\_traits} needs to be custom made.
Two models needs to be created for the AF macros:

\begin{enumerate}
	\item A \textit{TraitSpecifier} to hold an item passed to the \textit{interpolate\_traits} macro.
	      Each item will map a trait to its corresponding concrete type.
	\item \textit{AbstractFactoryAttribute} to hold the input passed to the \textit{abstract\_factory} macro.
	      The input will consist of a factory method and a list of elements the AF will create.
\end{enumerate}

\textit{TraitSpecifier} is defined in \Fref{lst:trait-specifier}.
It will use the syntax \textit{trait =$>$ concrete} to map a trait type to its concrete definition.

\libraryCodeFromFile[firstline=5,lastline=29]{macro-lib/src/trait_specifier.rs}{trait-specifier}{Making a parsable trait specifier}

Lines 1 and 2 import the \textit{syn} elements that will be used.
Line 9 is used by the tests.
The model is defined on lines 10 to 14 to hold the abstract trait, the arrow token, and the concrete.
The \textit{Token}\footnote{https://docs.rs/syn/1.0.48/syn/macro.Token.html} macro on line 12 is a helper from \textit{syn} to easily expand Rust tokens and punctuations.
Lines 17 to 25 implement the \textit{Parse}\footnote{https://docs.rs/syn/1.0.48/syn/parse/trait.Parse.html} trait from \textit{syn} for parsing a token stream to this model.
Here parsing is simple, \textit{parse} each stream token or propagate the errors.
\textit{Syn} will take care of converting the errors into compiler errors.

\textit{AbstractFactoryAttribute} is defined in \Fref{lst:abstract-factory-attribute-model}.
This will be the input passed to the \textit{abstract\_factory} macro.

\libraryCodeFromFile[firstline=7,lastline=27]{macro-patterns/src/abstract_factory.rs}{abstract-factory-attribute-model}{Meta-code model for abstract factory macro}

The model takes the factory method trait as the first input followed by a list of types the abstract factory will create as was shown in the client meta-code.

The expand method for the \textit{AbstractFactoryAttribute} model is defined as seen in \Fref{lst:abstract-factory-attribute-expand}.

\libraryCodeFromFile[firstline=29,lastline=48]{macro-patterns/src/abstract_factory.rs}{abstract-factory-attribute-expand}{Expanding an abstract factory macro model}

On lines 4 to 11 a factory method super trait is created for each type passed to the macro.
Lines 5 and 6 create local variables to be passed to \textit{quote}.
Line 8 uses a \textit{syn} helper function to turn a \textit{quote} into a syntax tree.
Since \textit{types} defined on line 5 is a list, \textit{quote} has to be told to expand each element in the list.
The \textit{\#(list-quote)$<$sep$>$*} quasiquote is used for to specify how to expand a list.
The optional \textit{sep} character is used as a separator for each item.
On line 9 the factory method is expanded for each type using the + (plus) sign as a separator.

Line 14 appends the factory super trait that was just constructed to the context input.
The new context input is returned on line 17.

\subsection{Visitor macro}