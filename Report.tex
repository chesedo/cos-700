\documentclass[a4paper,10pt]{article}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[dvipsnames]{xcolor}
\usepackage[pdftex]{graphicx}
\usepackage{listings}
\usepackage{lmodern}
\usepackage{mdframed}
\usepackage{url}

\usepackage{keyval}

\usepackage{fancyref}
\usepackage{minted}

\DeclareGraphicsRule{*}{mps}{*}{}

\newenvironment{code}[3][ht]
 {\VerbatimEnvironment
  \begin{listing}[#1]
  \caption{#2}\label{lst:#3}
  \begin{minted}[
    breaklines,
    escapeinside=||,
    linenos,
    xleftmargin=21pt
    ]{rust}}
 {\end{minted}\end{listing}}

\makeatletter

\define@key{embed}{pos}{\def\e@pos{#1}}
\define@key{embed}{firstline}{\def\e@firstline{#1}}
\define@key{embed}{lastline}{\def\e@lastline{#1}}

\setkeys{embed}{pos=ht,firstline=1,lastline=-1}
  
\newcommand{\embed}[3][]
 {\begingroup
  \setkeys{embed}{#1}
  \expandafter\listing\expandafter[\e@pos]
  \caption{#2}\label{lst:#3}
  \inputminted[
    autogobble,
    breaklines,
    linenos,
    firstline={\e@firstline},
    lastline={\e@lastline},
    firstnumber=1,
    xleftmargin=21pt
    ]{rust}{Code/#3/src/main.rs}
  \endlisting
  \endgroup}

\makeatother

\newcommand*{\fancyreflstlabelprefix}{lst}
\frefformat{vario}{\fancyreflstlabelprefix}{listing\fancyrefdefaultspacing#1#3}
\Frefformat{vario}{\fancyreflstlabelprefix}{Listing\fancyrefdefaultspacing#1#3}

\newmdenv[linecolor=BlueGreen,frametitle=Note,frametitlebackgroundcolor=BlueGreen!40!]{notebox}

\title
{
   \includegraphics[width=12cm]{up_logo.png} \\
   \vspace{2cm}
   \textbf{COS700 Research} \\ \vspace{0.5cm}
   \textbf{Design Pattern Metaprogramming Foundations in Rust\\ \large Abstract Factory and Visitor} \\ \vspace{0.5cm}
   \textbf{Student number:} u19239395 \\ \vspace{0.5cm}
   \textbf{Supervisor}: \\ Dr. Linda Marshall
}

\date{??? 2020}
\begin{document}
\author{}

\maketitle

\newpage
\linespread{1.25}

\section*{Abstract}

\section*{Keywords:}

\newpage

\section{Introduction}

\section{Design Patterns}
Software design is an activity focusing on the design and implementation of software to solve a particular problem \cite{ieee_1016-2009, satzinger_15_01}.
There should be no surprise to see some problems repeating themselves with time \cite{keshvari_11_01}.
The solutions to these problems are the same each time.
But a novice designer facing any of these repeated problems for the first time will try to solve them from first principles \cite{gamma_94_01, sonnentag_98_01}.
When the solution proves flawed or misunderstood some weeks later, a small improvement will be made to the solution \cite{zhu_05_01, ieee_1016-2009}.
These improvements are repeated until all the flaws are removed from the solution \cite{stephens_15_01, satzinger_15_01}.

On the other hand, seasoned designers create good designs from their own or their colleague's past experiences \cite{sonnentag_98_01}.
These solutions are easy to find in mature libraries and projects \cite{gamma_94_01}.
But novices are unlikely to get exposure to these projects \cite{zhu_05_01} or are just overwhelmed by their size \cite{hu_18_01}.
Having exposure to these projects will allow novices to jump to the good design directly.
Thus, saving time on the iteration process \cite{satzinger_15_01}.

But rather than taking novices to the projects, it might be possible to take the designs to the novices \cite{kim_03_01}.
This is exactly what happened in the 90s.
The Gang of Four took some of the repeated designs in projects and documented them in ``Design Patterns: Elements of Reusable Object-Oriented Software'' \cite{gamma_94_01}.

% TODO: consider GoF abbrivation

Each pattern is documented with a name, the problem it is solving, the solution and consequences of using the pattern.
Thus, each pattern is an explicit specification for the solution's design while the name becomes a vocabulary encapsulating the specification \cite{gamma_94_01, bulajic_12_01}.
This report will focus on only two of the patterns presented by the Gang of Four: Abstract Factory and Visitor.

% Maintenance if hard - "design for change" (anticipate type of change)

% Elements (p3)
%% Name
%% Problem
%% Solution
%% Consequences

\subsection{Abstract Factory}
During the instantiation of classes, four independent sets of problems might exist.
The Abstract Factory design pattern proposes to be a solution to these four problems. \cite{gamma_94_01}

\subsubsection{Problems}
The first problem is when the instantiation and representation of classes need to be separate from the application code.
Keeping data structures in a standard library and not the application code is an example of the first problem.
It can be argued that using Abstract Factory for this problem might be over-engineering the solution \cite{kerievsky_05_01}.

A second problem is the reverse of the first.
When a designer wants to create a library of objects but only expose their interface and not their implementation.
In a GUI library, only exposing the operations on a button and not the fact that the button is blue or glossy is an example of hiding the implementation.

The designer wanting to have a family of related objects to be used together is the third possible problem.
Forcing the glossy button to appear with the glossy scroller is an example of wanting the object families together.

Lastly, wanting to swap a family of products for another family of products is the fourth possible problem.
This is, swapping all the glossy GUI items to the flat blue items for the entire application by changing one line will be nice.

For this report, we will only focus on problems two to fourth.

\subsubsection{Solution}
Problems two and four requires each product to have an abstract definition - called \textit{Abstract Product}.
Doing so will hide the implementation for problem two - nothing that follows is really needed for problem two.
Meanwhile, for problem four, all the application code will operate against the interface for a button and scroller and not their concrete implementations.
Thus, swapping from the glossy to the blue elements will not require any additional code changes at the method calls.

\begin{figure}[h]
  \centering
  \includegraphics{AbstractFactory.1}
  \caption{Interfaces needed for Abstract Factory}
  \label{fig:AbstractFactoryInterface}
\end{figure}

Problems three and four both need to control the instantiation of a family of products.
Therefore, a class dedicated to products creation will be needed.
Problem four needs this class to be abstract to swap one family for another - hence why this class is called \textit{Abstract Factory}.

So far we have the design in \fref{fig:AbstractFactoryInterface}.

\begin{figure}[h]
  \centering
  \includegraphics{BlueFactory.1}
  \caption{Concrete BlueFactory}
  \label{fig:BlueFactory}
\end{figure}

\begin{figure}[h]
  \centering
  \includegraphics{GlossyFactory.1}
  \caption{Concrete GlossyFactory}
  \label{fig:GlossyFactory}
\end{figure}

Problem three does not need \textit{AbstractFactory} to be abstract.
Only problem four needs the abstraction to be able to swap one family for another.
\Fref{fig:BlueFactory} shows how the concrete blue GUI family maps to all the abstractions.
The same mapping can be seen for a glossy family in \fref{fig:GlossyFactory}.
Since both concrete designs have the same interface, swapping the one for the other is non-trivial.

\subsubsection{Consequences}
Thus, the \textit{Abstract Factory} pattern makes it easy to group a family of related products and to swap one family for another.
By having client code only work against the abstractions, the \textit{Abstract Factory} pattern also isolated the concrete implementations from the client code.

But, adding a new abstract product to the family creates a drawback.
Each concrete family will have to add its own concrete form of the product too.
Thus, the number of classes that need to change is \(n + 1\) where \(n\) is the number of families \cite{bulajic_12_01}.

% Adding new products is hard [gamma, buljic]
%% bulajic proposes db & Fowler quote (p1416)

\subsection{Visitor}
Performing an operation on a set of objects can be quite difficult.
The \textit{Visitor} design patterns proposes a solution to three problems \cite{gamma_94_01}.

\subsubsection{Problems}
For the first problem, imagine classes all with different interfaces.
But, an operation needs to be performed against each concrete class.
For example, a button and a scroller have different interfaces.
Yet, both have to be drawn.
Or a need might exist to read both aloud for the screen-reader.

Doing unrelated operations with the classes is a second problem.
For a study, a company might want to know the average screen surface area of its GUI elements.
This is unrelated to a GUI library.
Adding surface area methods to GUI classes will just pollute the classes.

Lastly, for the third problem, the classes may rarely change but the operations performed on them change often.
Coming back to the study, a week later finding the most common element color might be needed.
No new elements were added to the GUI library.
Only the need for a new operation exists.

\subsubsection{Solution}
The solution is to look outside the classes.
Thus, creating a new class which knows how to perform only a single operation.
The new class will need to visit each of the classes in the problem space.
This class is called \textit{Visitor} and solves problems one and two.

But problem three adds a new dimension.
Creating a new operation means creating a new visitor type.
Since they are both visiting the same classes, they are both the same in an abstract sense.
It is only their implementations that differ.
Thus, having an \textit{Abstract Visitor} to represent both is needed.

\textit{Abstract Visitor} will have a method for each class it needs to visit as seen in [to be made].
Requiring the client to remember the method corresponding to each class will not be ideal when the classes reach more than 30.
It is also not ideal for generic pieces of code since the method names are not the same.

To solve this, each class has a method to \textit{accept} a visitor.
This method calls for another abstraction called \textit{Element} with the \textit{accept} method.
In the \textit{accept} method, each class can call the visitor operation corresponding to it.

\subsubsection{Consequences}
New operations (\textit{Visitors}) can easily be added without touching the classes.
Related operations are now also isolated to each visitor, thus the classes are not polluted with unrelated methods.
Visitors also store the state information they need rather than passing it to each function.

% TODO: have state information in the diagram (color counter?) as an example

But, there are two problems.
First, adding a new class means updating all the visitors with a method for it.
Second, it is assumed each class exposes enough information through its public interface for visitors to perform their needed operations.

\section{Metaprogramming}
% So far not needed for selected patterns

\section{Rust}
Rust is a relatively new language created by Mozilla to be memory safe yet have low level like performance \cite{klabnik_2019_01}.
Traditionally, memory safe languages will make use of a garbage collector which slows performance \cite{hertz_05_01}.
Garbage collector languages include C\# \cite{robinson_04_01}, Java \cite{gosling_96_01}, Python \cite{martelli_06_01}, Golang \cite{tsoukalos_18_01} and Javascript \cite{flanagan_06_01}.
Languages that perform well use manual memory management, which is not memory safe whenever the programmer is not careful.
Dangling pointers \cite{caballero_12_01}, memory leaks \cite{wilson_92_01}, and double freeing \cite{sharp_13_01} in languages like C and C++ are prime examples of manual memory management problems \cite{konrad_18_01}.
Few languages have both memory safety and performance.
However, Rust achieves both by using a less popular model known as ownership.

\subsection{Ownership}
In the ownership model, the compiler uses statical analysis \cite{rasmussen_2019_01} to track which variable owns a piece of heap data -- this does not apply to stack data.
Each data piece can only be owned by one variable at a time.
The owning variable is called the \textit{owner}.
\cite{klabnik_2019_01}

A variable also has a scope.
The scope starts at the variable declaration and ends at the closing curly bracket of the code block containing the variable.
When the owner goes out of scope, Rust returns the memory by calling the \textit{drop} method at the end of the scope.
Ownership is manifested in two forms -- moving and borrowing.
These two forms are explained next.
\cite{klabnik_2019_01}

\subsubsection{Moving}
Moving happens when one variable is assigned to another.
The compiler's analysis moves ownership of the data to the new variable from the initial variable.
The initial variable's access is then invalidated \cite{klabnik_2019_01}.
An analogy example would be to give a book to a friend.
The friend can do anything from annotating to burning the book as they feel fit since the friend is the book's owner.

\embed[firstline=2,lastline=7]{Example of ownership transfer}{Rust/moved}

In \fref{lst:Rust/moved}, on line 2, a heap data object is created and assigned to variable \textit{s}.
Line 3 assigns \textit{s} to \textit{t}.
However, because \textit{s} is a heap object, the compiler transfers ownership of the data from \textit{s} to \textit{t} and marks \textit{s} as invalid.

When trying to use the data on line 5, via \textit{s}, the compiler, therefore, throws an error saying \textit{s} was moved.
Any reference to \textit{s} after line 3 will always give a compiler error.

Finally, the scope of \textit{t} ends on line 6.
Since the compiler can guarantee \textit{t} is the only variable owning the data, the compiler can free the memory on line 6.

\embed{Function taking ownership}{Rust/fn-move}

Having ownership moving makes excellent memory guarantees within a function; however, it is annoying when calling another function, as seen in \fref{lst:Rust/fn-move}.
The \textit{take\_ownership} function takes ownership of the heap data resulting in memory cleanup code correctly being inserted at the end of \textit{take\_ownership}'s scope on line 10.
When \textit{main} calls \textit{take\_ownership}, \textit{a} becomes the new owner of \textit{s}'s data, making the call on line 5 invalid.
When taking ownership is not desired, the second form of ownership, borrowing, should be used instead.

\subsubsection{Borrowing}

Borrowing has a new variable take references to data rather than becoming its new owner \cite{klabnik_2019_01}.
An analogy is borrowing a book from a friend with a promise of returning the book to its owner once done with it.

\embed{Function taking borrow}{Rust/fn-borrow}

As seen in \fref{lst:Rust/fn-borrow}, borrowing makes the function \textit{take\_borrow} take a reference to the data.
References are activated with an ampersand (\textit{\&}) before the type.
Once \textit{take\_borrow} has ended, control goes back to \textit{main} - where the cleanup code will be inserted.
Having references as function parameters is called borrowing \cite{klabnik_2019_01}.
The ampersand is also used in the call argument to signal the called function will borrow the data.

However, in Rust, all variables are immutable by default \cite{klabnik_2019_01}.
Hence changing the data in \textit{take\_borrow} causes an error stating the borrow is not mutable on line 9.
Returning to the borrowed book analogy.
One would not make highlights and notes in a book one borrowed unless the owner gave explicit permission.

\subsection{Immutable by default}
Mutable borrows are an explicit indication that a function/variable is allowed to change the data.

\embed{Function taking mutable borrow}{Rust/fn-mut-borrow}

As seen in \fref{lst:Rust/fn-mut-borrow}, mutable borrows are activated using \textit{\&mut } on the type.
Again, \textit{mut} is also used in the call to make it explicit the function will modify the data.
Variables -- on the stack or heap -- also need to be declared \textit{mut} to use them as mutable.
\cite{klabnik_2019_01}

The two ownership forms - moving and borrowing - together with mutable variables put some constraints on the code of each variable type and their calls: \cite{klabnik_2019_01}
\begin{itemize}
  \item Moving will always invalidate the variable.
  \item Borrowed variables cannot be mutated.
        However, more than one function can borrow the data simultaneously in parallel and concurrent code.
  \item Mutable borrowing does allow mutations.
        But only one function can hold a mutable borrow at a time and no other immutable borrows can exist.
\end{itemize}

The constraints will always be enforced by the compiler, thus requiring all code to meet them.
Meeting these constraints also requires some shift in thinking at times.
Another shift is required because Rust may not classify as an Object-Oriented Programming (OOP) language.

\subsection{Not quite OOP}
No single definition exists to qualify a language as Object-Oriented \cite{meyer_97_01,stefik_85_01,gamma_94_01,klabnik_2019_01}.
Three Object-Oriented definitions will be explored to understand Rust better.
These three are Objects as Data and their Behaviour, Encapsulation, and Inheritance.

\subsubsection{Objects as Data and their Behaviour}
The first definition of Object-Oriented design is a language using objects.
An object, in turn, holds both data and procedures operating on the data \cite{meyer_97_01,stefik_85_01,gamma_94_01}.
Rust meets the data with their operations requirement by holding the data in \textit{struct}s and having the operations defined in \textit{impl} blocks \cite{klabnik_2019_01}.

\paragraph{Struct}
A \textit{struct} is the same as a \textit{struct} in C \cite{stroustrup_13_01} and other C like languages \cite{robinson_04_01, savitch_15_01, malik_09_01}.
Structs are used to define objects with named data pieces, as shown in \fref{lst:Rust/oop} lines 1 to 5.
Each of the struct properties is named followed by a type.

\embed[lastline=44,pos=p!]{Example of a Struct}{Rust/oop}

\paragraph{Methods}
The operations to perform on a struct are defined in an \textit{impl} block, as seen in lines 7 - 19 in \fref{lst:Rust/oop}.
Notice how the ownership rules apply to the struct.

The methods \textit{get\_age} and \textit{have\_birthday} will take a borrow of the struct object.
To age, while having a birthday, \textit{have\_birthday} needs to take a mutable borrow of \textit{self} - also why \textit{bar} needs to be \textit{mut} in \textit{main}.
The method \textit{have\_burial} moves \textit{self}, thus invalidating any objects of \textit{Foo} after \textit{have\_burial} is called - resulting in a compile error on line 33.
The same error happened in \fref{lst:Rust/fn-move}.

\begin{notebox}
  Rust does not always use the \textit{return} keyword.
  The missing semi-colon on line 9 is deliberate and the Rust way to say we want to return the age for the Foo instance.
\end{notebox}

\subsubsection{Encapsulation}
The next definition deals with hiding implementation details from the client - known as encapsulation \cite{klabnik_2019_01, meyer_97_01}.
Encapsulation allows the struct creator to change the internal procedures of the struct without affecting the public interface used by clients.
Rust also meets the encapsulation definition by using the \textit{pub} keyword.

\paragraph{pub}
As can be seen in \fref{lst:Rust/oop}, the \textit{Foo} struct and its \textit{name} data member is made public explicitly.
The methods \textit{get\_age} and \textit{have\_birthday} are also made public explicitly.
All the other data members and methods are private - Rust's default - and unreachable by client code.
A curious question then is why can \textit{main} access the private variables and methods.
The answer being: \textit{main} is located in the same module/file as the struct and therefore has full access to it.

\begin{notebox}
  Rust does not provide constructors like other OOP languages.
  Instead, Rust has what it calls associate methods.
  An associate method is a method definition not containing \textit{self} in the parameter list \cite{klabnik_2019_01}.
  A constructor like associate-method will return an owned instance of the struct being constructed.
  \Fref{lst:Rust/oop}, lines 36 to 44 shows an example of an associate method for Foo defined in the same file as Foo's definition.
  Yes, Rust code can have multiple \textit{impl} blocks for a single struct.
\end{notebox}

\subsubsection{Inheritance}
The last definition being looked at is inheritance.
Inheritance has an object inherit some of its data members and procedures from a parent object \cite{meyer_97_01, stefik_85_01, gamma_94_01}.
Inheritance is mostly used to reduce code duplication.
Rust does not meet the inheritance definition for OOP.

The Gang of Four made their design patterns for Object-Oriented languages.
They also define two principles for Object-Oriented design \cite{gamma_94_01}.
\begin{itemize}
  \item ``Program to an interface, not an implementation.''
        Rust meets this requirement by using \textit{traits}.
  \item ``Favor object composition over class inheritance.''
        The lack of inheritance will, therefore, not be an issue in Rust.
        Not having inheritance causes Rust code to use composition naturally.
\end{itemize}

Rust \textit{traits} cause it to meet both requirements allowing Rust to implement the Gang of Four design patterns.

\subsection{Traits}
\textit{Traits} are similar \cite{klabnik_2019_01} to \textit{interfaces} in other languages like C\# \cite{robinson_04_01} and Java \cite{gosling_96_01}.
In C++, \textit{abstract classes} are the equivalent of \textit{interfaces} \cite{malik_09_01,stroustrup_13_01,alexandrescu_01_01}.
Thus, \textit{traits} allow the definition of abstract behavior as seen in \fref{lst:Rust/traits}, lines 1 to 7.

\embed[firstline=3,lastline=35,pos=p!]{Working with traits}{Rust/traits}

The compiler uses \textit{traits} at compile time to guarantee an object implements a set of methods using \textit{trait bounds}.
Line 9 shows the \textit{work} function having a \textit{trait bound} on the generic \textit{T} type.
Thus, any object choosing to implement the \textit{Show} trait can be passed to \textit{work}.
In turn, \textit{work} knows it is safe to call \textit{show()} on the object for type \textit{T}.

More complex trait bounds can be constructed as shown on line 13.
Here \textit{T} (\textit{first}) has to implement the traits: \textit{Show} to be able to call the \textit{show()} method on \textit{first}; \textit{Display} to pass it to \textit{println!}; \textit{PartialEq} to compare it with \textit{U} (\textit{second}).
Trait bounds this complex become hard to read, so Rust offers an alternative syntax for placing trait bounds on generics as seen in lines 19 to 22.

Traits are implemented using the \textit{impl} keyword followed by the trait name as seen on line 29.
The \textit{Show} trait has a default implementation for \textit{show\_size}.
Thus, \textit{Tester} does not need to implement \textit{show\_size} and chooses only to implement the \textit{show} method.

Generics and traits are a good match since they result in static dispatch function calls.

\subsubsection{Static Dispatch}
When Rust sees generics on a function or type, Rust uses what it calls \textit{monomorphization} \cite{klabnik_2019_01}.
\textit{Monomorphization} creates a new function or type at compile time for each concrete object passed into the generic placeholders.
Thus, at compile-time, the compiler knows exactly which version of the expanded function to call.
Knowing which function to call at compile-time is known as \textit{compile-time binding} \cite{malik_09_01} or \textit{static dispatch} \cite{klabnik_2019_01, alexandrescu_01_01}.
Using just \textit{trait objects} - rather than generics - will result in dynamic dispatch.

\subsubsection{Dynamic Dispatch}
Dynamic dispatch \cite{alexandrescu_01_01, klabnik_2019_01} happens when the compiler cannot determine which method to call because the \textit{self} object is not fixed.
Instead, at run-time, pointers inside the trait objects are used to determine which method to call \cite{klabnik_2019_01}, hence why it is also known as \textit{run-time binding} \cite{malik_09_01}.

\Fref{lst:Rust/traits-dyn-dispatch} shows \textit{work} with dynamic dispatch rather than generics.

\embed[firstline=5,lastline=7]{Dynamic Dispatch with \textit{dyn}}{Rust/traits-dyn-dispatch}

Three changes need to be made to the function signature.
\begin{itemize}
  \item The generic \textit{T} is removed and replaced with \textit{Show}.
  \item The \textit{dyn} keyword is added to the type to indicate dynamic dispatch will take place explicitly \cite{klabnik_2019_01}.
  \item Borrowing now takes place.
\end{itemize}

The static dispatch generic trait examples can also be made to take a borrow, but taking ownership gives a compile-time error with dynamic dispatch.
The special \textit{Sized} trait is the cause of the error.

\subsubsection{Sized trait}
Rust keeps all local variables and function arguments on the stack.
Having values on the stack requires their size to be known at compile-time.
A special trait called \textit{Sized} is used by the compiler to make sure this requirement is met. \cite{klabnik_2019_01}

The size of an object is influenced by the data it holds.
Also, any object can choose to implement \textit{Show}.
Ownership will want to pass each object on the stack, but each object will need a different stack size only known at run-time.
However, pointers have a fixed size.
Therefore, putting the dynamic object behind any pointer means the stack size will be fixed.

\begin{notebox}
  \textit{Sized} is a unique Rust trait.
  It is the only trait automatically added as a trait bound on all generics.
  For this reason, a special syntax is needed when the programmer wants to opt-out of the \textit{Sized} trait bound.
  The syntax in question is the \textit{?Sized} trait bound. \cite{klabnik_2019_01}
\end{notebox}

Rust offers many pointer options: \cite{klabnik_2019_01}
\begin{itemize}
  \item A reference - also called a borrow.
  \item The \textit{Box$<$T$>$} used to hold heap objects.
        \textit{Box} differs from a reference since \textit{Box} owns its \textit{T} \footnote{https://joshleeb.com/blog/rust-traits-trait-objects/}.
  \item The \textit{Rc$<$T$>$} reference counting pointer that is essentially a run-time immutable borrow.
        When the reference count reaches zero, the \textit{T} is dropped.
  \item The special \textit{RefCell$<$T$>$} which exposes mutable access behind an immutable object using the \textit{Interior Mutability Pattern}.
  \item The combined \textit{Rc$<$RefCell$<$T$>$$>$} - the reference counting pointer allows multiple objects to exist, while the \textit{RefCell} allows mutable access to each existing object.
  \item \textit{Arc$<$T$>$} - the thread-safe version of \textit{Rc}.
  \item \textit{Mutex$<$T$>$} - a thread-safe version of \textit{RefCell}.
        However, a lock needs to be acquired first.
  \item \textit{RwLock$<$T$>$} - like \textit{Mutex}, but distinguishes between a reader and a writer.
  \item Finally, \textit{Arc$<$RwLock$<$T$>$$>$} which will be used by our Abstract Factory.
        It will hold \textit{T}s for use in multiple threads using \textit{Arc}, while \textit{RwLock} will guarantee only one writer.
\end{itemize}

One more Rust uniqueness is left to be covered. Rust treats enums differently than other languages.

\subsection{Enums}
In Rust, enums can also hold objects \cite{klabnik_2019_01} as seen in \fref{lst:Rust/enums}, lines 1 to 3.
The \textit{Option} enum, as defined here, is built into the standard Rust library \cite{klabnik_2019_01} to replace \textit{null} as used in other languages.
An \textit{Option} can either be \textit{Some} object or \textit{None}.
This is yet another design Rust uses to be memory safe \footnote{Tony Hoare, the inventor of the \textit{null} reference, has called the \textit{null} reference a billion-dollar mistake in his 2009 presentation "Null References: The Billion Dollar Mistake" (https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/)} by checking the ``\textit{null}'' (\textit{None}) option is handled at compile-time.

\embed{Enums holding objects in Rust}{Rust/enums}

Lines 9 to 12 show the use of \textit{match} - called a \textit{switch} in most languages - to match against each possible enum variant.
Line 10 and 11 are each called a \textit{match arm}.
Line 10 shows how an object can be extracted on an arm and be assigned to a value variable.
If any of the two arms are missing, the compiler will give an error stating not all the enum options are covered.
Because matches need to be exhaustive - i.e. all variants need to be covered - in Rust.
There are two options for getting around the exhaustive check. \cite{klabnik_2019_01}

Either adding the \textit{\_} (underscore) catch-all arm to handle the default case for all missing enum options.
Alternatively, using the \textit{if let} pattern as seen on line 14.
The \textit{if let} pattern also allows extraction of the enum object.
However, since the object is not used inside the if block, no extraction needs to occur.
The \textit{\_} is, therefore, used to not extract the enum object.

Both \textit{if} and \textit{match} blocks are considered expressions in Rust.
Thus, lines 16 and 18 miss their ending semi-colon to return \textit{true} and \textit{false} from the \textit{if}.
The value returned from the \textit{if} is assigned to \textit{valid}.
Returning from a \textit{match} is quite common, especially with a particular enum used for error handling.

\subsubsection{Result enum for error handling}
While other languages use exceptions to propagate errors up to the caller, Rust uses the \textit{Result} enum instead.
The definition for \textit{Result} can be seen in \fref{lst:Rust/enum-result} on lines 1 to 4.

\embed[lastline=40,pos=p!]{The \textit{Result} enum}{Rust/enum-result}

A function will return \textit{Result} to indicate if it was successful with the \textit{Ok} variant holding the successful value of type \textit{T}.
In the event of an error, the \textit{Err} variant is returned with the error of type \textit{E} - like \textit{may\_error} on line 7.
Any calls to \textit{may\_error} have to handle the possible error.
A few error handling options exist: trying an alternative, panicking, or propagating the error.

\paragraph{Alternative}
Trying an alternative if quite simple.
If the \textit{Err} enum is returned, then just run the alternative instead.

\paragraph{Panicking}
The caller will use a \textit{match pattern} to extract the error and panic as seen on lines 13 to 16.
However, writing matches all the time for possible errors break the flow of the code.
So the \textit{Result} enum has some helper methods defined on it \footnote{https://doc.rust-lang.org/std/result/enum.Result.html} - yes, Rust enums are like ordinary objects that can have methods.

The helper method \textit{expect}, as seen on line 22, does the exact same as the match on lines 13 to 16.

\paragraph{Propagation}
The caller might decide more information is need to panic.
So the caller's caller will need to handle the error instead.

Line 30 shows how to propagate the error up the stack - the \textit{return} is to return from the function and not the match.
Line 29 uses the result if it is fine - the lack of \textit{return} returns from the match and assigns \textit{result} to \textit{r}.
Again, the match is verbose and Rust offers a helper to make it shorter.
The helper is the \textit{?} (question mark) operator.
The \textit{?} operator can be used in any function returning a \textit{Result} or \textit{Option} - or type implementing the \textit{std::ops::Try} trait \cite{klabnik_2019_01}.
Line 37 shows how to use \textit{?} - doing precisely the same as lines 28 to 31.

% macro rules: Hygiene and token list

% Generics
%% Associate types

\section{Reporting}

\section{Conclusion}


\bibliographystyle{alpha}
\bibliography{References}

\end{document}