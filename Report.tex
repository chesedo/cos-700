\documentclass[a4paper,10pt]{article}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{color}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{lmodern}
\usepackage{mdframed}
\usepackage{url}

\usepackage{minted}

\title
{
   \includegraphics[width=12cm]{up_logo.png} \\
   \vspace{2cm}
   \textbf{COS700 Research} \\ \vspace{0.5cm}
   \textbf{Design Pattern Metaprogramming Foundations in Rust\\ \large Abstract Factory and Visitor} \\ \vspace{0.5cm}
   \textbf{Student number:} u19239395 \\ \vspace{0.5cm}
   \textbf{Supervisor}: \\ Dr. Linda Marshall
}

\date{??? 2020}
\begin{document}
\author{}

\maketitle

\newpage
\linespread{1.25}

\section*{Abstract}

\section*{Keywords:}

\newpage

\section{Introduction}

\section{Design Patterns}

\subsection{Abstract Factory}

\subsection{Visitor}

\section{Metaprogramming}
% So far not needed for selected patterns

\section{Rust}
Rust is a new language created by Mozilla with the aim on being memory safe yet performant. Traditionally, most languages that are memory safe will make use of a garbage collector which slows performance. Languages that perform well uses memory management which is not memory safe.

\subsection{Ownership}
To achieve both memory safety and performance, Rust uses a less popular method known as ownership. In the ownership method the compiler keeps track of which variable owns a piece of memory. Each memory piece can only be owned by one variable at a time. When the variable goes out of scope, the compiler inserts memory cleanup code at the end of the block scope. Ownership is manifested in three forms - moving, borrowing and mutable borrowing. These three are explained next.

\subsubsection{Moving}
Moving happens when one variable is assigned to another. The compiler's state machine moves ownership of the underlying memory to the new variable from the initial variable.
% rewrite

\begin{listing}[ht]
   \begin{minted}[linenos]{rust}
   {
      let s = String::from("string");
      let t = s;

      println!("String len is {}", s.len()); // borrow of moved value: `s`
   } // Compiler will add memory clean up code for t here
   \end{minted}
   \caption{Example of ownership transfer}
   \label{lst:moved}
\end{listing}

In listing \ref{lst:moved}, on line 2 a new on heap memory object is created and assigned to variable \textit{s}. Line 3 has the memory from \textit{s} assigned to \textit{t}. But, because \textit{s} is a heap object, the compiler transfers ownership of the memory from \textit{s} to \textit{t}.

When trying to use the memory on line 5, via \textit{s}, the compiler therefore throws an error saying that \textit{s} was moved. In fact any reference to \textit{s} after line 3 will always give a compiler error.

Finally, the scope of \textit{t} ends on line 6. Since the compiler is able to guarantee \textit{t} is the only variable using the underlying memory, the compiler can therefore safely insert the memory cleanup code for the heap object on line 6.

\begin{listing}[ht]
   \begin{minted}[linenos]{rust}
      fn main() {
         let s = String::from("string");
         take_ownership(s);

         println!("String len is {}", s.len()); // borrow of moved value: `s`
      }

      fn take_ownership(a: String) {
         // some code working on a
      } // Compiler will add memory clean up code for a here
   \end{minted}

   \caption{Function taking ownership}
   \label{lst:fn-move}
\end{listing}

Having ownership moving makes great memory guarantees within a function, but is annoying when calling another function as seen in Listing \ref{lst:fn-move}. The \textit{take\_ownership} function takes ownership of the memory. When \textit{main} calls \textit{take\_ownership} the compiler registers a transfer of the memory owner, thus making the call on line 5 invalid. On the upside, the cleanup code is correctly inserted on line 10.

\begin{listing}[ht]
   \begin{minted}[linenos]{rust}
      fn main() {
         let s = String::from("string");
         take_borrow(&s);

         println!("String len is {}", s.len());
      } // Compiler will add memory clean up code for s here

      fn take_borrow(a: &String) {
         a.push_str("suffix"); // cannot borrow a as mutable
      }
   \end{minted}

   \caption{Function taking borrow}
   \label{lst:fn-borrow}
\end{listing}

The solution is the second form of ownership, borrowing. As seen in Listing \ref{lst:fn-borrow}, borrow makes the function \textit{take\_borrow} only take temporary control of the memory. Once \textit{take\_borrow} has ended, control goes back to \textit{main} - where the cleanup code will be inserted. Borrowing is activated with an ampersand (\textit{\&}) before the type and in the call.

But in Rust, all variable are immutable by default. So trying to change the underlying memory in \textit{take\_borrow} causes an error stating the borrow is not mutable on line 9.

\begin{listing}[ht]
   \begin{minted}[linenos]{rust}
      fn main() {
         let mut s = String::from("string");
         take_borrow(&mut s);

         println!("String len is {}", s.len());
      } // Compiler will add memory clean up code for s here

      fn take_borrow(a: &mut String) {
         a.push_str("suffix");
      }
   \end{minted}

   \caption{Function taking mutable borrow}
   \label{lst:fn-mut-borrow}
\end{listing}

Being unable to change the variable naturally leads to the third and last ownership form, mutable borrows. As seen in Listing \ref{lst:fn-mut-borrow}, mutable borrows are activated using \textit{\&mut } on the type and call. Mutable ownership one the other hand just need \textit{mut} when the variable is declared.

The three ownership forms - moving, borrowing and mutable borrowing - put some constraints on the code of each variable type and their calls:
\begin{itemize}
   \item Moving will always invalidate the variable.
   \item Borrowed variables cannot be mutated. But more than one function can borrow the memory at the same time.
   \item Mutable borrowing does allow mutations. But only one function can hold a mutable borrow at a time and no other immutable borrows can exist.
\end{itemize}

The constraints will always be enforced by the compiler, thus requiring all code to meet them.

% Not OOP
%% Structs
%% No constructors
%% Composition over inheritance

% Traits
%% Bounds
%% Defaults

% Sized
% - Because stack is default
%% Opting out

% Generics
%% Associate types

% Enums
%% Pattern matching

\section{Reporting}

\section{Conclusion}


\bibliographystyle{alpha}
\bibliography{References}

\end{document}